* 6.22<br>
  令每个磁道宽度为A，磁道上每个扇区长度为B，每个扇区容量为C，则磁盘总容量为
  $$S=\frac{(1-x)r}{A}\times\frac{2\pi xr}{B}\times C$$
  其中第一项为磁道数，第二项为每个磁道扇区数。已知A,B,C,r,π均为常数，故
  $$S\propto -x^2+x$$
  此二次函数有极大值，极值点在x=1/2处。所以x取0.5时磁盘容量最大
  * 6.23<br>
  $$T_{access}=T_{avg seek}+T_{avg rotation}+T_{avg transfer}=4+1/2\times60/15000\times1000+60/15000\times1/800\times1000=6.005ms$$
  参考6.1.2节示例
* 6.24<br>
  A:
  $$T_{avg seek}=4ms$$
  $$T_{avg rotation}=1/2\times60/15000\times1000=2ms$$
  $$T_{avg transfer}=2000/0.5/1000\times60/15000\times1000=16ms$$
  $$T_{access}=T_{avg seek}+T_{avg rotation}+T_{avg transfer}=22ms$$
  B:
  $$T_{access}=2000/0.5*(T_{avg seek}+T_{avg rotation})=24s$$
  参考习题6.4
* 6.25<br>
  | 高速缓存 | m   | C    | B   | E   | S   | t   | s   | b   |
  | -------- | --- | ---- | --- | --- | --- | --- | --- | --- |
  | 1        | 32  | 1024 | 4   | 4   | 64  | 24  | 6   | 2   |
  | 2        | 32  | 1024 | 4   | 256 | 1   | 30  | 0   | 2   |
  | 3        | 32  | 1024 | 8   | 1   | 128 | 22  | 7   | 3   |
  | 4        | 32  | 1024 | 8   | 128 | 1   | 29  | 0   | 3   |
  | 5        | 32  | 1024 | 32  | 1   | 32  | 22  | 5   | 5   |
  | 6        | 32  | 1024 | 32  | 4   | 8   | 24  | 3   | 5   |
* 6.26<br>
  | 高速缓存 | m   | C    | B   | E   | S   | t   | s   | b   |
  | -------- | --- | ---- | --- | --- | --- | --- | --- | --- |
  | 1        | 32  | 2048 | 8   | 1   | 256 | 21  | 8   | 3   |
  | 2        | 32  | 2048 | 4   | 4   | 128 | 23  | 7   | 2   |
  | 3        | 32  | 1024 | 2   | 8   | 64  | 25  | 6   | 1   |
  | 4        | 32  | 1024 | 32  | 2   | 16  | 23  | 4   | 5   |
* 6.27<br>
  A:组1包含两行<br>
  对于标记为45的行命中的地址中t=45=0b01000101, s=001, b=00-11，对应的16位地址为0x08A4-0x08A7<br>
  对于标记为38的行命中的地址中t=38=0b00111000, s=001, b=00-11，对应的16位地址为0x0704-0x0707<br>
  B:思路同上，0x1238~0x123B
* 6.28<br>
  思路同6.27<br>
  A:无命中<br>
  B:0x18F0-0x18F3, 0x00B0-0x00B3<br>
  C:0x0E34-0x0E37<br>
  D:0x1BDC-0x1BDF<br>
* 6.29<br>
  A: |CT|CT|CT|CT|CT|CT|CT|CT|CI|CI|CO|CO|<br>
  B:
  | 操作 | 地址  | 命中                              | 值   |
  | ---- | ----- | --------------------------------- | ---- |
  | 读   | 0x834 | 否                                | 未知 |
  | 写   | 0x836 | 是(第一次读miss时加载数据到cache) | 未知 |
  | 读   | 0xFFD | 是                                | C0   |
* 6.30<br>
  A: $C=S\times E\times B=8\times4\times4=128B$<br>
  B: |CT|CT|CT|CT|CT|CT|CT|CT|CI|CI|CI|CO|CO|<br>
* 6.31<br>
  A: |0|0|1|1|1|0|0|0|1|1|0|1|0|<br>
  B:
  | 参数               | 值   |
  | ------------------ | ---- |
  | 高速缓存块偏移(CO) | 0x2  |
  | 高速缓存组索引(CI) | 0x6  |
  | 高速缓存标记(CT)   | 0x38 |
  | 高速缓存命中       | 是   |
  | 返回的高速缓存字节 | 0xEB |
* 6.32<br>
  A: |1|0|1|1|0|1|1|1|0|1|0|0|0|<br>
  B:
  | 参数               | 值   |
  | ------------------ | ---- |
  | 高速缓存块偏移(CO) | 0x0  |
  | 高速缓存组索引(CI) | 0x2  |
  | 高速缓存标记(CT)   | 0xB7 |
  | 高速缓存命中       | 否   |
  | 返回的高速缓存字节 | -    |
* 6.33<br>
  思路同6.27<br>
  0x1788-0x178B, 0x16C8-0x16CB<br>
* 6.34<br>
  参考习题6.17<br>
  dst数组
   |     | 列0 | 列1 | 列2 | 列3 |
   | --- | --- | --- | --- | --- |
   | 行0 | m   | m   | m   | m   |
   | 行1 | m   | m   | m   | m   |
   | 行2 | m   | m   | m   | m   |
   | 行3 | m   | m   | m   | m   |

  src数组
   |     | 列0 | 列1 | 列2 | 列3 |
   | --- | --- | --- | --- | --- |
   | 行0 | m   | m   | h   | m   |
   | 行1 | m   | h   | m   | h   |
   | 行2 | m   | m   | h   | m   |
   | 行3 | m   | h   | m   | h   |
* 6.35<br>
  dst数组
   |     | 列0 | 列1 | 列2 | 列3 |
   | --- | --- | --- | --- | --- |
   | 行0 | m   | h   | h   | h   |
   | 行1 | m   | h   | h   | h   |
   | 行2 | m   | h   | h   | h   |
   | 行3 | m   | h   | h   | h   |

  src数组
   |     | 列0 | 列1 | 列2 | 列3 |
   | --- | --- | --- | --- | --- |
   | 行0 | m   | h   | h   | h   |
   | 行1 | m   | h   | h   | h   |
   | 行2 | m   | h   | h   | h   |
   | 行3 | m   | h   | h   | h   |
* 6.36<br>
  读访问总次数为128*2=256次<br>
  A: 512字节恰好可以放下x[0]或x[1]所有元素，故x[0]和x[1]的对应元素映射到cache的相同组。交替读x[0]和x[1]的元素会导致抖动现象，没有读可以命中缓存，不命中率为100%。<br>
  B: 1024字节可以放下x所有元素，只会发生冷不命中(每个块的第一次读)，不命中率为1/4=25%。<br>
  C: 同A，x[0]和x[1]的对应元素映射到相同组。由于是两路组相联，x[1]的缓存不会将x[0]缓存替换掉，因此直到cache用完之前(前64个循环)只存在冷不命中，不命中率为1/4=25%。后64次循环cache已经被占满，需要替换已有数据。由于执行LRU策略，每次替换关系是固定的，即x[0][64]->x[0][0]，x[1][64]->x[1][0]，x[0][65]->x[0][1]，x[1][65]->x[1][1]，...x[0]与x[1]不会出现冲突，因此只在每个块第一次读取时出现冲突不命中，不命中率为1/4=25%。综上，不命中率为25%。<br>
  D: 不会。增加缓存大小无法避免冷不命中，而25%是冷不命中的下限。<br>
  E: 可以。增加块大小可以使冷不命中导致的不命中率降低。<br>
* 6.37<br>
  缓存组数为4096B/16B=256，用0-255表示，每组可以保存4个元素
  1. sumA<br>
    读取步长为1，每次缓存加载数据后会依次读取，只存在冷不命中，不命中率与N无关，只取决于块大小，1/4=25%。
  2. sumB<br>
    读取步长为N，第i次读操作地址映射到缓存的第 $(i*N/4)\%256$ 组。<br>
    N=64时，i=0-N次读操作映射到缓存的第0,16,...240,0,16,...240,...组，后续的数据会将之前的数据替换掉。当j+1时，新循环的数据需要重新加载到缓存，所有操作均无法命中，不命中率为100%。<br>
    N=60时，i=0-N次读操作映射到缓存的第0,15,...255,14,29,...254,...组，数据之间有偏移量，不会替换之前的数据。当j+1时，新一轮循环的数据不需要重新加载，直到缓存块中的4组数据都访问过，只存在冷不命中，1/4=25%。<br>
  3. sumC<br>
    N=64时，在一次循环中，a[i][j+1]和a[i+1][j]可以命中，不命中率为2/4=50%；而当j+2后，与sumB N=64情况类似，新循环的数据需要重新加载到缓存，无法命中缓存，因此不命中率即单次循环中的50%。<br>
    N=60时，与sumB N=60情况类似，不命中率为25%。<br>

  综上
   | 函数 | N=64 | N=60 |
   | ---- | ---- | ---- |
   | sumA | 25%  | 25%  |
   | sumB | 100% | 25%  |
   | sumC | 50%  | 25%  |
* 6.38<br>
  缓存有2048B/32B=64组<br>
  A: $16\times16\times4=1024$<br>
  B: 访问步长为1，每组可以保存2个square结构体，每两次循环有一次冷不命中，不命中的写总数为 $16\times16/2=128$<br>
  C: 128/1024=12.5%<br>
* 6.39<br>
  A: $16\times16\times4=1024$<br>
  B: j=0到8时，每个循环内访问步长为1，有1次冷不命中；每组可以保存128个square结构体，j>8后与之前的地址映射到相同的缓存组，每个循环发生1次冲突不命中。不命中数与循环数相同，为 $16\times16=256$ 次
  <br>
  C: 256/1024=25%<br>
* 6.40<br>
  A: $16\times16+16\times16\times3=1024$<br>
  B: 对于y循环，与6.38类似，不命中的写总数为 $16\times16/2=128$；cmk循环类似，因为y循环后一半循环会将前一半数据替换，不命中的写总数为 $16\times16/2=128$，共256次<br>
  C: 256/1024=25%<br>
* 6.41<br>
  缓存有64KB/4B=16K组，每组可以存放一个pixel结构体。每个循环内访问步长为1，仅存在1次冷不命中，每组有4次访问，不命中率为1/4=25%
* 6.42<br>
  访问步长为1，存在1次冷不命中，每组有4次访问，不命中率为1/4=25%
* 6.43<br>
  访问步长为1，存在1次冷不命中，每组有1次访问，不命中率为1/1=100%
* 6.44<br>
  测试程序下载路径：http://csapp.cs.cmu.edu/3e/mountain.tar<br>
  测试结果<br>
  Clock frequency is approx. 2904.0 MHz<br>
  Memory mountain (MB/sec)

  |       | s1    | s2    | s3    | s4    | s5    | s6    | s7    | s8    | s9    | s10   | s11   | s12   | s13   | s14   | s15   |
  | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
  | 128m  | 18598 | 10581 | 7310  | 5189  | 4342  | 3627  | 3085  | 2586  | 2427  | 2230  | 2041  | 1924  | 1782  | 1730  | 1718  |
  | 64m   | 18494 | 11002 | 7512  | 5424  | 4434  | 3702  | 3197  | 2760  | 2469  | 2325  | 2150  | 2007  | 1914  | 1811  | 1749  |
  | 32m   | 18887 | 11350 | 7908  | 5582  | 4519  | 3799  | 3404  | 3001  | 2712  | 2520  | 2365  | 2195  | 2098  | 1978  | 1861  |
  | 16m   | 19442 | 12566 | 8815  | 7117  | 5699  | 4658  | 4198  | 3580  | 3379  | 3197  | 3114  | 2922  | 2918  | 2799  | 2854  |
  | 8m    | 23243 | 14770 | 10585 | 8631  | 7523  | 6797  | 6083  | 5488  | 5607  | 5639  | 5648  | 5587  | 5593  | 5663  | 5717  |
  | 4m    | 31767 | 23692 | 19323 | 15441 | 13123 | 11397 | 10038 | 8931  | 8648  | 8268  | 8037  | 7768  | 7574  | 7409  | 7259  |
  | 2m    | 32652 | 24997 | 20463 | 16293 | 13562 | 11712 | 10232 | 9088  | 8722  | 8360  | 8064  | 7810  | 7613  | 7445  | 7234  |
  | 1024k | 32590 | 24695 | 20272 | 16340 | 13593 | 11796 | 10318 | 9109  | 8739  | 8350  | 8076  | 7786  | 7598  | 7409  | 7288  |
  | 512k  | 32646 | 24960 | 20549 | 16426 | 13695 | 11727 | 10324 | 9119  | 8765  | 8464  | 8273  | 8001  | 8018  | 8017  | 8163  |
  | 256k  | 33822 | 27032 | 23818 | 20736 | 17868 | 15716 | 13737 | 12444 | 12207 | 12024 | 12029 | 12839 | 10520 | 10495 | 11105 |
  | 128k  | 34927 | 29816 | 28614 | 27057 | 24384 | 22058 | 18920 | 16475 | 16683 | 16556 | 14774 | 16166 | 15716 | 15899 | 16091 |
  | 64k   | 34366 | 28880 | 27450 | 24152 | 19742 | 17341 | 14014 | 13751 | 13703 | 14024 | 13686 | 14022 | 14117 | 15715 | 27227 |
  | 32k   | 39600 | 37494 | 37359 | 36769 | 36179 | 36043 | 36057 | 34181 | 35118 | 35498 | 39670 | 38485 | 35873 | 34320 | 37529 |
  | 16k   | 39983 | 38936 | 38031 | 36940 | 34721 | 36367 | 34148 | 35192 | 35954 | 36874 | 34048 | 34469 | 32381 | 33640 | 34848 |
* 6.45<br>
  linux系统下使用命令```lscpu```可以查看cpu的整体参数，包括cache。在测试机器上结果如下
  ```shell
  $ lscpu
  Architecture:          x86_64
  CPU op-mode(s):        32-bit, 64-bit
  Byte Order:            Little Endian
  CPU(s):                6
  On-line CPU(s) list:   0-5
  Thread(s) per core:    1
  Core(s) per socket:    6
  Socket(s):             1
  Vendor ID:             GenuineIntel
  CPU family:            6
  Model:                 158
  Model name:            Intel(R) Core(TM) i5-9400F CPU @ 2.90GHz
  Stepping:              10
  CPU MHz:               2904.008
  BogoMIPS:              5808.01
  Hypervisor vendor:     Microsoft
  Virtualization type:   full
  L1d cache:             32K
  L1i cache:             32K
  L2 cache:              256K
  L3 cache:              9216K
  ```
  可以看到L1-cache为32K，L2-cache为256K，L3-cache为9216K.
  其中L1-cache又分为L1d(Data cache)与L1I(instruction cache)<br>
  使用命令```cat /sys/devices/system/cpu/cpu0/cache/index*```可以查看cache的具体参数，主要参数含义为：<br>
  level - cache等级<br>
  type - cache类型(Data,Instruction,Unified)<br>
  size - cache大小，即C<br>
  number_of_sets - 组数，即S<br>
  ways_of_associativity - 每组相联路数，即E<br>
  coherency_line_size - block大小，即B<br>
  在测试机器上L1d cache参数如下
  ```shell
  $ cat /sys/devices/system/cpu/cpu0/cache/index0/level
  1
  $ cat /sys/devices/system/cpu/cpu0/cache/index0/type
  Data
  $ cat /sys/devices/system/cpu/cpu0/cache/index0/size
  32K
  $ cat /sys/devices/system/cpu/cpu0/cache/index0/number_of_sets
  64
  $ cat /sys/devices/system/cpu/cpu0/cache/index0/ways_of_associativity
  8
  $ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size
  64
  ```
  基于cache参数进行优化<br>
  (1)参考6.6.2节的blocking优化方法，对于较大的矩阵通过分块处理使其能被cache容纳，提高缓存命中率<br>
  (2)每个block内使用循环展开进一步提升性能<br>
  (3)在测试机上当block大小=128，使用 $8\times 1$ 循环展开时性能最好<br>
  具体代码见test_6.45.c。在测试机器上对于N=15000的矩阵测试结果如下：
  ```shell
  $ ./test
  transpose:
  Run 10, avg time =1744.366000 ms
  perf_transpose_128_8
  Run 10, avg time =353.025800 ms
  ```
* 6.46<br>
  与6.45思路类似，注意到结果矩阵是对称矩阵，可以只遍历矩阵的一半以提高性能<br>
  在测试机上当block大小=256，使用 $16\times 1$ 循环展开时性能最好<br>
  具体代码见test_6.46.c。在测试机器上对于N=15000的矩阵测试结果如下：
  ```shell
  $ ./test
  convert:
  Run 10, avg time =1992.027800 ms
  perf_convert_256_16
  Run 10, avg time =731.047700 ms